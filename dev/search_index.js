var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Algorithm-Core-Functions","page":"API","title":"Algorithm Core Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DistributedResourceOptimization]\nPrivate = false\nPages = [\"algorithm/core.jl\"]","category":"page"},{"location":"api/#DistributedResourceOptimization.CoordinatedDistributedAlgorithm","page":"API","title":"DistributedResourceOptimization.CoordinatedDistributedAlgorithm","text":"CoordinatedDistributedAlgorithm\n\nA struct representing the core of a coordinated distributed optimization algorithm. This type encapsulates the necessary data and methods for coordinating multiple agents or processes in a distributed resource optimization setting.\n\n\n\n\n\n","category":"type"},{"location":"api/#DistributedResourceOptimization.Coordinator","page":"API","title":"DistributedResourceOptimization.Coordinator","text":"Coordinator\n\nAn abstract type representing the coordinator in distributed resource optimization algorithms. Concrete implementations of this type are responsible for managing and coordinating the optimization process across distributed resources.\n\n\n\n\n\n","category":"type"},{"location":"api/#DistributedResourceOptimization.DistributedAlgorithm","page":"API","title":"DistributedResourceOptimization.DistributedAlgorithm","text":"DistributedAlgorithm\n\nAn abstract type representing the base for distributed optimization algorithms. Subtypes should implement specific distributed algorithm logic for resource optimization.\n\n\n\n\n\n","category":"type"},{"location":"api/#DistributedResourceOptimization.on_exchange_message-Tuple{DistributedAlgorithm, Carrier, Any, Any}","page":"API","title":"DistributedResourceOptimization.on_exchange_message","text":"on_exchange_message(algorithm::DistributedAlgorithm, carrier::Carrier, message_data::Any, meta::Any)\n\nHandles an incoming exchange message within the distributed algorithm framework.\n\nArguments\n\nalgorithm::DistributedAlgorithm: The distributed algorithm instance managing the exchange.\ncarrier::Carrier: The communication carrier responsible for message delivery.\nmessage_data::Any: The data contained in the received message.\nmeta::Any: Additional metadata associated with the message.\n\nDescription\n\nProcesses the received exchange message, updating the algorithm's state or triggering appropriate actions based on the message content and metadata.\n\nReturns\n\nMay return a result or perform side effects depending on the implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/#DistributedResourceOptimization.start_optimization-Tuple{Coordinator, Carrier, Any, Any}","page":"API","title":"DistributedResourceOptimization.start_optimization","text":"start_optimization(coordinator::Coordinator, carrier::Carrier, message_data::Any, meta::Any)\n\nInitiates the optimization process using the provided coordinator and carrier objects.  The function takes arbitrary message_data and meta information to configure or inform the optimization run.\n\nArguments\n\ncoordinator::Coordinator: The main coordinator responsible for managing the optimization workflow.\ncarrier::Carrier: The carrier object that facilitates communication or data transfer during optimization.\nmessage_data::Any: Additional data or messages required for the optimization process.\nmeta::Any: Communication Metadata or supplementary information relevant to the optimization.\n\nReturns\n\nThe result of the optimization process, which may vary depending on the implementation.\n\nNotes\n\nEnsure that coordinator and carrier are properly initialized before calling this function.\nThe types of message_data and meta are flexible to accommodate various use cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#Carrier-Core","page":"API","title":"Carrier Core","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DistributedResourceOptimization]\nPrivate = false\nPages = [\"carrier/core.jl\"]","category":"page"},{"location":"api/#DistributedResourceOptimization.Carrier","page":"API","title":"DistributedResourceOptimization.Carrier","text":"Carrier\n\nAn abstract type representing a generic data/communication carrier in the system. Concrete subtypes should implement specific carrier behaviors and properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.wait-Tuple{Carrier, Any}","page":"API","title":"Base.wait","text":"Base.wait(carrier::Carrier, waitable::Any)\n\nWaits for the specified waitable object to become ready or complete within the context of the given carrier.  This function integrates with the Carrier's scheduling or resource management logic to handle asynchronous or blocking operations.\n\nArguments\n\ncarrier::Carrier: The carrier instance managing the waiting operation.\nwaitable::Any: The object or resource to wait for. This can be any type that supports waiting semantics.\n\nNotes\n\nThe function blocks until the waitable is ready or the operation is complete.\n\n\n\n\n\n","category":"method"},{"location":"api/#DistributedResourceOptimization.others-Tuple{Carrier, String}","page":"API","title":"DistributedResourceOptimization.others","text":"others(carrier::Carrier, participant_id::String)\n\nReturns a collection of participants in the given carrier excluding the participant with the specified participant_id.\n\nArguments\n\ncarrier::Carrier: The carrier object containing participants.\nparticipant_id::String: The identifier of the participant to exclude.\n\nReturns\n\nA collection (e.g., array or set) of participants other than the one with participant_id.\n\n\n\n\n\n","category":"method"},{"location":"api/#DistributedResourceOptimization.reply_to_other-Tuple{Carrier, Any, Any}","page":"API","title":"DistributedResourceOptimization.reply_to_other","text":"reply_to_other(carrier::Carrier, content_data::Any, meta::Any)\n\nReply using the given carrier to another entity, using the provided content_data and  meta information.\n\nArguments\n\ncarrier::Carrier: The carrier object responsible for communication.\ncontent_data::Any: The data to be sent in the reply.\nmeta::Any: Additional metadata associated with the reply.\n\nReturns\n\nThe result of the reply operation, depending on the implementation.\n\nNotes\n\nThe specific behavior depends on the implementation details of the Carrier type.\n\n\n\n\n\n","category":"method"},{"location":"api/#DistributedResourceOptimization.schedule_using-Tuple{Carrier, Function, Float64}","page":"API","title":"DistributedResourceOptimization.schedule_using","text":"schedule_using(carrier::Carrier, to_be_scheduled::Function, delay_s::Float64)\n\nSchedules the execution of the provided function to_be_scheduled using the specified carrier after a delay of delay_s seconds.\n\nArguments\n\ncarrier::Carrier: The carrier object responsible for scheduling.\nto_be_scheduled::Function: The function to be executed after the delay.\ndelay_s::Float64: The delay in seconds before executing the function.\n\nReturns\n\nImplementation-dependent. Typically, returns a handle or status indicating the scheduled task.\n\n\n\n\n\n","category":"method"},{"location":"api/#DistributedResourceOptimization.send_and_wait_for_answers-Tuple{Carrier, Any, Any}","page":"API","title":"DistributedResourceOptimization.send_and_wait_for_answers","text":"send_and_wait_for_answers(carrier::Carrier, content_data::Any, receivers::Any)\n\nSends content_data using carrier to the given receivers and waits for their responses.\n\nArguments\n\ncarrier::Carrier: The carrier object responsible for sending the data.\ncontent_data::Any: The data to be sent to the receivers.\nreceivers::Any: The target receivers to which the data will be sent.\n\nReturns\n\nReturns the responses received from the receivers after sending the data.\n\nNotes\n\nThis function blocks execution until all expected answers are received from the receivers.\n\n\n\n\n\n","category":"method"},{"location":"api/#DistributedResourceOptimization.send_awaitable-Tuple{Carrier, Any, Any}","page":"API","title":"DistributedResourceOptimization.send_awaitable","text":"send_awaitable(carrier::Carrier, content_data::Any, receiver::Any)\n\nSends an awaitable message using the specified carrier to the given receiver with the provided content_data.\n\nArguments\n\ncarrier::Carrier: The carrier object responsible for message transmission.\ncontent_data::Any: The data to be sent in the message.\nreceiver::Any: The target recipient of the message.\n\nReturns\n\nReturns an awaitable object or handle that can be used to track the completion or response of the sent message.\n\n\n\n\n\n","category":"method"},{"location":"api/#DistributedResourceOptimization.send_to_other-Tuple{Carrier, Any, Any}","page":"API","title":"DistributedResourceOptimization.send_to_other","text":"send_to_other(carrier::Carrier, content_data::Any, receiver::Any)\n\nSends content_data using the specified carrier to the given receiver.\n\nArguments\n\ncarrier::Carrier: The carrier object responsible for sending the data.\ncontent_data::Any: The data to be sent.\nreceiver::Any: The target receiver of the data.\n\nReturns\n\nThe result of the send operation, which may vary depending on the implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mango-Carrier","page":"API","title":"Mango Carrier","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DistributedResourceOptimization]\nPrivate = false\nPages = [\"carrier/mango.jl\"]","category":"page"},{"location":"api/#DistributedResourceOptimization.CoordinatorRole","page":"API","title":"DistributedResourceOptimization.CoordinatorRole","text":"CoordinatorRole\n\nA role struct representing the coordinator in the distributed resource optimization system. Used to identify and manage coordinator-specific logic and responsibilities within the carrier module.\n\n\n\n\n\n","category":"type"},{"location":"api/#DistributedResourceOptimization.CoordinatorRole-Tuple{Coordinator}","page":"API","title":"DistributedResourceOptimization.CoordinatorRole","text":"CoordinatorRole(coordinator::Coordinator; include_self=false, tid::Symbol = :default)\n\nAssigns the coordinator role to the specified coordinator object. \n\nArguments\n\ncoordinator::Coordinator: The coordinator instance to assign the role to.\ninclude_self::Bool=false: If true, includes the coordinator itself in the role assignment.\ntid::Symbol=:default: An optional identifier symbol for neighbor lookups.\n\nReturns\n\nReturns the configured coordinator role.\n\n\n\n\n\n","category":"method"},{"location":"api/#DistributedResourceOptimization.DistributedOptimizationRole","page":"API","title":"DistributedResourceOptimization.DistributedOptimizationRole","text":"DistributedOptimizationRole\n\nA role struct used to define distributed optimization responsibilities within the system. Attach this role to entities that participate in distributed resource optimization processes.\n\n\n\n\n\n","category":"type"},{"location":"api/#DistributedResourceOptimization.DistributedOptimizationRole-Tuple{DistributedAlgorithm}","page":"API","title":"DistributedResourceOptimization.DistributedOptimizationRole","text":"DistributedOptimizationRole(algorithm::DistributedAlgorithm; tid::Symbol = :default)\n\nCreates and returns a distributed optimization role using the specified algorithm.  An optional identifier tid can be provided, defaulting to :default.\n\nArguments\n\nalgorithm::DistributedAlgorithm: The distributed optimization algorithm to be used.\ntid::Symbol: (Optional) Identifier for the neighbor lookup. Defaults to :default.\n\nReturns\n\nA distributed optimization role configured with the given algorithm and an identifier to specify the addresses of other participants.\n\n\n\n\n\n","category":"method"},{"location":"api/#DistributedResourceOptimization.MangoCarrier","page":"API","title":"DistributedResourceOptimization.MangoCarrier","text":"MangoCarrier <: Carrier\n\nA concrete implementation of the Carrier type representing a mango carrier. Extend this struct with relevant fields and methods to model the behavior and properties of a mango carrier in the distributed resource optimization context.\n\n\n\n\n\n","category":"type"},{"location":"api/#DistributedResourceOptimization.OptimizationFinishedMessage","page":"API","title":"DistributedResourceOptimization.OptimizationFinishedMessage","text":"OptimizationFinishedMessage\n\nA message struct indicating that an optimization process has completed. Typically used for signaling the end of an optimization routine in distributed or parallel computation contexts.\n\n\n\n\n\n","category":"type"},{"location":"api/#ADMM-Sharing","page":"API","title":"ADMM Sharing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DistributedResourceOptimization]\nPrivate = false\nPages = [\"algorithm/admm/sharing_admm.jl\"]","category":"page"},{"location":"api/#DistributedResourceOptimization.create_sharing_admm_coordinator-Tuple{ADMMGlobalObjective}","page":"API","title":"DistributedResourceOptimization.create_sharing_admm_coordinator","text":"create_sharing_admm_coordinator(objective::ADMMGlobalObjective)\n\nArguments\n\nobjective::ADMMGlobalObjective: The global objective function to be used in the AD\n\n\n\n\n\n","category":"method"},{"location":"api/#ADMM-Consensus","page":"API","title":"ADMM Consensus","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DistributedResourceOptimization]\nPrivate = false\nPages = [\"algorithm/admm/consensus_admm.jl\"]","category":"page"},{"location":"api/#ADMM-Flex","page":"API","title":"ADMM Flex","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DistributedResourceOptimization]\nPrivate = false\nPages = [\"algorithm/admm/flex_actor.jl\"]","category":"page"},{"location":"api/#DistributedResourceOptimization.create_admm_flex_actor_one_to_many","page":"API","title":"DistributedResourceOptimization.create_admm_flex_actor_one_to_many","text":"create_admm_flex_actor_one_to_many(in_capacity::Real, η::Vector{Float64}, P::Union{Nothing,Vector{<:Real}}=nothing)\n\nCreates an ADMM flex actor for a one-to-many resource allocation scenario.\n\nArguments\n\nin_capacity::Real: The input capacity of the resource.\nη::Vector{Float64}: Vector of efficiency parameters for the ADMM algorithm.\nP::Union{Nothing,Vector{<:Real}}: Optional vector of priorities. If not provided, defaults to nothing.\n\nReturns\n\nA flex actor object configured for one-to-many ADMM optimization.\n\nNotes\n\nThis function is typically used in distributed resource optimization problems where a single resource is allocated to multiple consumers using the ADMM algorithm.\n\n\n\n\n\n","category":"function"},{"location":"carrier/mango/","page":"Mango","title":"Mango","text":"To use the distributed algorithms, the role DistributedOptimizationRole can be used to integrate an algorithm. ","category":"page"},{"location":"carrier/mango/","page":"Mango","title":"Mango","text":"Some Distributed Algorithms require a coordinator, in this case another role can be used additionally CoordinatorRole.","category":"page"},{"location":"getting_started/#Using-the-sharing-ADMM-with-flex-actors-(e.g.-for-resource-optimization)-with-Mango.jl","page":"Getting Started","title":"Using the sharing ADMM with flex actors (e.g. for resource optimization) with Mango.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\nusing DistributedResourceOptimization\n\n@role struct HandleOptimizationResultRole\n    got_it::Bool = false\nend\n\nfunction Mango.handle_message(role::HandleOptimizationResultRole, message::OptimizationFinishedMessage, meta::Any)\n    role.got_it = true\nend\n\ncontainer = create_tcp_container(\"127.0.0.1\", 5555)\n\n# create participant models\nflex_actor = create_admm_flex_actor_one_to_many(10, [0.1, 0.5, -1])\nflex_actor2 = create_admm_flex_actor_one_to_many(15, [0.1, 0.5, -1])\nflex_actor3 = create_admm_flex_actor_one_to_many(10, [0.1, 0.5, -1])\n\n# create coordinator with objective\ncoordinator = create_sharing_target_distance_admm_coordinator()\n\n# create roles to integrate admm in Mango.jl\ndor = DistributedOptimizationRole(flex_actor, tid=:custom)\ndor2 = DistributedOptimizationRole(flex_actor2, tid=:custom)\ndor3 = DistributedOptimizationRole(flex_actor3, tid=:custom)\ncoord_role = CoordinatorRole(coordinator, tid=:custom, include_self=true)\n\n# role to handle a result\nhandle = HandleOptimizationResultRole()\nhandle2 = HandleOptimizationResultRole()\nhandle3 = HandleOptimizationResultRole()\n\n# create agents\nadd_agent_composed_of(container, dor, handle)\nc = add_agent_composed_of(container, dor2, handle2)\nca = add_agent_composed_of(container, coord_role, dor3, handle3)\n\n# create a topology of the agents\nauto_assign!(complete_topology(3, tid=:custom), container)\n\n# run the simulation with start message and wait for result\nactivate(container) do\n    wait(send_message(c, StartCoordinatedDistributedOptimization(create_admm_start(create_admm_sharing_data([0.2, 1, -2]))), address(ca)))\n    wait(coord_role.task)\nend","category":"page"},{"location":"getting_started/#Using-COHDA-with-Mango.jl","page":"Getting Started","title":"Using COHDA with Mango.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Mango\nusing DistributedResourceOptimization\n\ncontainer = create_tcp_container(\"127.0.0.1\", 5555)\n\n# create agents with local model wrapped in the general distributed optimization role\nagent_one = add_agent_composed_of(container, DistributedOptimizationRole(\n    create_cohda_participant(1, [[0.0, 1, 2], [1, 2, 3]])))\nagent_two = add_agent_composed_of(container, DistributedOptimizationRole(\n    create_cohda_participant(2, [[0.0, 1, 2], [1, 2, 3]])))\n\n# create start message\ninitial_message = create_cohda_start_message([1.2, 2, 3])\n\n# create topology\nauto_assign!(complete_topology(2), container)\n\n# run simulation\nactivate(container) do\n    send_message(agent_one, initial_message, address(agent_two))\nend","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"In DRO.jl every ADMM optimization consists of two components, the ADMM problem form itself, and the local model, which determines local constraints and objectives.","category":"page"},{"location":"algorithms/admm/#Problem-Form","page":"ADMM","title":"Problem Form","text":"","category":"section"},{"location":"algorithms/admm/#Consensus","page":"ADMM","title":"Consensus","text":"","category":"section"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"The single global variable consensus form can be written as","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"beginequation\nbeginsplit\nmin_x_iz sum_i=1^N f_i(x_i) \nquadtextstquad x_i = z i=1dotsN\nendsplit\nendequation","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"where f_i is the local objective of agent i, x_i the decision variable of this agent.","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"With the dual variable u and the penalty rho the update iteration reads.","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"beginalign\nx_i^k+1 \n= argmin_x_i \nf_i(x_i) \n+ fracrho2big x_i - big(z^k - u_i^k big) big_2^2\n\nz^k+1 \n= argmin_z \ng(z) + fracN rho2left \nz - Big( barx^k+1 + baru^k Big) \nright_2^2 \nu_i^k+1 \n= u_i^k + x_i^k+1 - z^k+1\nendalign","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"To instantiate a coordinator for the sharing form, use create_consensus_target_reach_admm_coordinator. To start the neotiation you need to use create_admm_start_consensus.","category":"page"},{"location":"algorithms/admm/#Sharing","page":"ADMM","title":"Sharing","text":"","category":"section"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"Take the sharing problem:","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"beginequation\nbeginsplit\nmin_x_iz sum_i=1^N f_i(x_i) + g(z)\nquadtextstquad sum_i=1^N x_i = z i=1dotsN\nendsplit\nendequation","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"where f_i is the local objective of agent i, x_i the decision variable of this agent, and g the global objective.","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"With the dual variable u and the penalty rho the generic update iteration reads.","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"beginalign\nx_i^k+1 \n  = argmin_x_i\n     f_i(x_i) + tfracrho2biglVert x_i - (z^k - u^k) bigrVert_2^2\n    \n     i=1dotsN \n     6pt\nz^k+1 \n  = argmin_z\n     g(Ncdot z) + tfracNrho2biglVert z - barx^k+1 - u^k bigrVert_2^2\n     \nbarx^k+1 \n  = tfrac1Nsum_i=1^N x_i^k+1\n     6pt\nu^k+1 \n  = u^k + barx^k+1 - z^k+1 \n     \nendalign","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"To instantiate a coordinator for the sharing form, use create_sharing_admm_coordinator. To start the negotiation you can use create_admm_start.","category":"page"},{"location":"algorithms/admm/#Local-Models","page":"ADMM","title":"Local Models","text":"","category":"section"},{"location":"algorithms/admm/#Flexibility-Actor","page":"ADMM","title":"Flexibility Actor","text":"","category":"section"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"Each local actor ìhas some flexibility ofmresources and a decision on the provided flexibilityx_i`. The decision is constrained by","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"lower and upper bounds l_i leq x_i leq u_i\ncoupling constraints C_i x_ileq d_i\nlinear penalites S_i for priorization","category":"page"},{"location":"algorithms/admm/","page":"ADMM","title":"ADMM","text":"To instantiate a flexibility actor use create_admm_flex_actor_one_to_many.","category":"page"},{"location":"carrier/simple/","page":"Simple","title":"Simple","text":"TBD","category":"page"},{"location":"algorithms/cohda/","page":"COHDA","title":"COHDA","text":"COHDA is a distributed optimization heuristic, which solves MC-COP (Multiple Choice Combinatorial Optimization Problem). ","category":"page"},{"location":"algorithms/cohda/","page":"COHDA","title":"COHDA","text":"COHDA minimizes the distance of the sum of a set of schedules (distributedly chosen) to a target vector.","category":"page"},{"location":"algorithms/cohda/","page":"COHDA","title":"COHDA","text":"beginequation\n  beginsplit\n      undersetx_rm ijtextmaxleft(-lVert T - sum_i=1^Nsum_j=1^M (U_rm ijcdot x_rm ij)rVert_1right)\n      textwith  sum_j=1^Mx_rm ij = 1\n      x_rm ijinleft01righti=1dotsNj=1dotsM\n  endsplit\nendequation","category":"page"},{"location":"algorithms/cohda/","page":"COHDA","title":"COHDA","text":"To use COHDA create_cohda_participant and create_cohda_start_message can be used.","category":"page"},{"location":"#Distributed-Resource-Optimization-for-Julia","page":"Home","title":"Distributed Resource Optimization for Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package DistributedResourceOptimization.jl (DRO) aims to provide a collection of distributed optimization algorithms for optimizing distributed resources. The algorithms are implemented without considering one special communication technique or package. DRO provides abstract types and function interfaces to implement so-called carriers, which are able to execute the distributed algorithms asynchronous. All algorithms can also be used without carrier using fitting @spawn or @async statements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently there are three tested algorithms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ADMM multi-value consensus such that the sum of all resp values equals a target vector\nADMM sharing variant on flexibility providing resources\nCOHDA, Combinatorial Optimization Heuristic for Distributed Agents, which minimizes the distance of schedule sums to a given target schedule","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is one carrier implemented:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mango.jl, agent framework for the simulation of distributed systems, DO provides roles to which the specific algorithms can be assigned to","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the package is highly work in progress. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, DRO is available on the general Julia registry, and can therfore be installed calling ]add DistributedResourceOptimization.","category":"page"}]
}
